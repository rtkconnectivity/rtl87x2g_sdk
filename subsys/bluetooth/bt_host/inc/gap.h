/**
*****************************************************************************************
*     Copyright(c) 2016, Realtek Semiconductor Corporation. All rights reserved.
*****************************************************************************************
  * @file    gap.h
  * @brief   This file contains all the constants and function prototypes for GAP.
  * @details This file is used for both BR/EDR and LE.
  * @author  jane
  * @date    2017-02-18
  * @version v1.0
  * *************************************************************************************
  */

/*============================================================================*
 *               Define to prevent recursive inclusion
 *============================================================================*/
#ifndef GAP_H
#define GAP_H

#ifdef __cplusplus
extern "C"
{
#endif

/*============================================================================*
 *                        Header Files
 *============================================================================*/
#include <stdint.h>
#include <stdbool.h>
#include "bt_types.h"
#include "gap_chann.h"

/** @addtogroup GAP_COMMON GAP Common
  * @brief GAP common module.
  * @{
  */

/*============================================================================*
 *                         Macros
 *============================================================================*/
/** @defgroup GAP_Common_Exported_Macros GAP Common Exported Macros
  * @{
  */

/** @defgroup GAP_Common_Macros GAP Common Macros
  * @{
  */
#define GAP_BD_ADDR_LEN               6     //!< Bluetooth Device Address length.
#define GAP_KEY_LEN                   16    //!< Length of Identity Resolving Key(IRK), maximum length of Long Term Key(LTK).
#define GAP_DEVICE_NAME_LEN           (39+1)//!< Maximum length of device name; if device name length exceeds it, device name will be truncated.
#define GAP_PASSCODE_MAX              999999//!< Maximum Pairing Passkey value. Range of a passkey can be 000,000 - 999,999.
#define GAP_OOB_LEN                   16    //!< Length of Out of Band data.
/**
  * @}
  */

/** @defgroup BOND_PAIRING_MODE_DEFINES Pairing Modes
 * @{
 */
#define GAP_PAIRING_MODE_NO_PAIRING          0x00  //!< Device does not allow pairing.
#define GAP_PAIRING_MODE_PAIRABLE            0x01  //!< Device allows pairing.
/**
  * @}
  */

/** @defgroup BOND_AUTHEN_REQ Authentication Requirements
 * @{
 */
#define GAP_AUTHEN_BIT_NONE                  0      //!<  No authentication required.
#define GAP_AUTHEN_BIT_BONDING_FLAG          0x0001 //!<  Bonding is required.
#define GAP_AUTHEN_BIT_GENERAL_BONDING_FLAG  0x0002 //!<  General bonding is required.
#define GAP_AUTHEN_BIT_MITM_FLAG             0x0004 //!<  MITM is preferred.
#define GAP_AUTHEN_BIT_SC_FLAG               0x0008 //!<  Secure connection is preferred.
#define GAP_AUTHEN_BIT_KEYPRESS_FLAG         0x0010 //!<  Keypress notification is preferred.
#define GAP_AUTHEN_BIT_CT2_FLAG              0x0020 //!<  CT2 flag is preferred.
#define GAP_AUTHEN_BIT_FORCE_BONDING_FLAG    0x0100 //!<  Force bonding is required.
#define GAP_AUTHEN_BIT_SC_ONLY_FLAG          0x0200 //!<  Secure connection only mode for Bluetooth LE is required.
#define GAP_AUTHEN_BIT_SC_BR_FLAG            0x0400 //!<  Secure connection for BR/EDR is required.
#define GAP_AUTHEN_BIT_FORCE_CENTRAL_ENCRYPT_FLAG 0x0800 //!<  When stored keys are generated by no MITM pairing method, and MITM requirement is preferred, Central role prefers encrypting a connection directly rather than re-pair.
/**
  * @}
  */

/** @defgroup BOND_KEY_CONVERT Link Key Conversion Flags
 * @{
 */
#define GAP_SC_KEY_CONVERT_NONE              0x00 //!< Do not perform any Link Key Conversion.
#define GAP_SC_KEY_CONVERT_LE_TO_BREDR_FLAG  0x01 //!< Link Key Conversion from LE to BR/EDR.
/**
  * @}
  */

/** @defgroup GAP_COMMON_MSG_TYPE GAP Msg Type
 * @{
 */
#define GAP_MSG_WRITE_AIRPLAN_MODE      0x00 //!< Response msg type for @ref gap_write_airplan_mode. The structure of callback data is @ref T_GAP_WRITE_AIRPLAN_MODE_RSP.
#define GAP_MSG_READ_AIRPLAN_MODE       0x01 //!< Response msg type for @ref gap_read_airplan_mode. The structure of callback data is @ref T_GAP_READ_AIRPLAN_MODE_RSP.
#define GAP_MSG_SET_LOCAL_BD_ADDR       0x02 //!< Response msg type for @ref gap_set_bd_addr. The structure of callback data is @ref T_GAP_SET_BD_ADDR_RSP.
#define GAP_MSG_VENDOR_CMD_RSP          0x03 //!< Response msg type for @ref gap_vendor_cmd_req. The structure of callback data is @ref T_GAP_VENDOR_CMD_RSP.
#define GAP_MSG_GAP_CHANN_ADDED         0x08 //!< Information for L2CAP channel added. This L2CAP channel can transmit ATT PDU. The structure of callback data is @ref T_GAP_CHANN_ADDED.
#define GAP_MSG_GAP_CHANN_DEL           0x09 //!< Information for L2CAP channel removed. The structure of callback data is @ref T_GAP_CHANN_DEL.
#define GAP_MSG_GAP_CHANN_MTU_UPDATE    0x0A //!< Information for L2CAP channel MTU updated. The structure of callback data is @ref T_GAP_CHANN_MTU_UPDATE.

#define GAP_MSG_VENDOR_EVT_INFO         0x16 //!< Information for vendor-specific events. The structure of callback data is @ref T_GAP_VENDOR_EVT_INFO.

#define GAP_MSG_GAP_READ_AFH_CHANNEL_ASSESSMENT_MODE           0x17 /**< Response msg type for @ref gap_read_afh_channel_assessment_mode.
                                                                     *   The structure of callback data is @ref T_GAP_READ_AFH_CHANNEL_ASSESSMENT_MODE_RSP. */
#define GAP_MSG_GAP_WRITE_AFH_CHANNEL_ASSESSMENT_MODE          0x18 /**< Response msg type for @ref gap_write_afh_channel_assessment_mode.
                                                                     *   The structure of callback data is @ref T_GAP_WRITE_AFH_CHANNEL_ASSESSMENT_MODE_RSP. */
/**
  * @}
  */

/** End of GAP_Common_Exported_Macros
  * @}
  */

/*============================================================================*
 *                         Types
 *============================================================================*/
/** @defgroup GAP_Common_Exported_Types GAP Common Exported Types
  * @{
  */

/** @brief IO Capabilities. */
typedef enum
{
    GAP_IO_CAP_DISPLAY_ONLY,        //!< Only a Display present, no Keyboard or Yes/No Keys.
    GAP_IO_CAP_DISPLAY_YES_NO,      //!< Display and Yes/No Keys present.
    GAP_IO_CAP_KEYBOARD_ONLY,       //!< Only a Keyboard present, no Display.
    GAP_IO_CAP_NO_INPUT_NO_OUTPUT,  //!< No input/output capabilities.
    GAP_IO_CAP_KEYBOARD_DISPLAY,    //!< Keyboard and Display present.
} T_GAP_IO_CAP;

/** @brief Key types. */
typedef enum
{
    GAP_KEY_COMBINATION           = 0x00, /**< Combination key. */
    GAP_KEY_LOCAL_UNIT            = 0x01, /**< Local unit key. */
    GAP_KEY_REMOTE_UNIT           = 0x02, /**< Remote unit key. */
    GAP_KEY_DEBUG_COMBINATION     = 0x03, /**< Debug combination key. */
    GAP_KEY_UNAUTHEN              = 0x04, /**< SSP generated link key without MITM protection. */
    GAP_KEY_AUTHEN                = 0x05, /**< SSP generated link key with MITM protection. */
    GAP_KEY_CHANGED_COMBINATION   = 0x06, /**< Changed combination key. */
    GAP_KEY_UNAUTHEN_P256         = 0x07, /**< Secure Connections generated link key without MITM protection. */
    GAP_KEY_AUTHEN_P256           = 0x08, /**< Secure Connections generated key with MITM protection. */
    GAP_KEY_LE_LOCAL_LTK          = 0x11, /**< Bluetooth LE Local Long Term Key. */
    GAP_KEY_LE_REMOTE_LTK         = 0x12, /**< Bluetooth LE Remote Long Term Key. */
    GAP_KEY_LE_LOCAL_IRK          = 0x13, /**< Bluetooth LE Local Identity Resolving Key. */
    GAP_KEY_LE_REMOTE_IRK         = 0x14, /**< Bluetooth LE Remote Identity Resolving Key. */
    GAP_KEY_LE_LOCAL_CSRK         = 0x15, /**< Bluetooth LE Local Connection Signature Resolving Key. */
    GAP_KEY_LE_REMOTE_CSRK        = 0x16, /**< Bluetooth LE Remote Connection Signature Resolving Key. */
    GAP_KEY_REQ_BR                = 0x80, /**< Only used to request a BR/EDR link key. */
    GAP_KEY_DELETE                = 0xFF  /**< Link key is no longer valid and should be deleted. */
} T_GAP_KEY_TYPE;

/** @brief Keypress notification type. */
typedef enum
{
    GAP_PASSKEY_ENTRY_STARTED,     /**< Passkey entry started. */
    GAP_PASSKEY_DIGIT_ENTERED,     /**< Passkey digit entered. */
    GAP_PASSKEY_DIGIT_ERASED,      /**< Passkey digit erased. */
    GAP_PASSKEY_CLEARED,           /**< Passkey cleared. */
    GAP_PASSKEY_ENTRY_CMPL,        /**< Passkey entry completed. */
} T_GAP_KEYPRESS_NOTIF_TYPE;

/** @brief GAP Remote Address Type. */
typedef enum
{
    GAP_REMOTE_ADDR_LE_PUBLIC          = 0x00, /**< LE Public device address type. */
    GAP_REMOTE_ADDR_LE_RANDOM          = 0x01, /**< LE Random device address type. */
    GAP_REMOTE_ADDR_LE_PUBLIC_IDENTITY = 0x02, /**< LE Public identity address type. */
    GAP_REMOTE_ADDR_LE_RANDOM_IDENTITY = 0x03, /**< LE Random identity address type. */
    GAP_REMOTE_ADDR_CLASSIC            = 0x10, /**< BR/EDR device address type. */
    GAP_REMOTE_ADDR_LE_ANONYMOUS       = 0xFF, /**< LE anonymous device address type. */
} T_GAP_REMOTE_ADDR_TYPE;

/** @brief GAP Cause. */
typedef enum
{
    GAP_CAUSE_SUCCESS           = 0x00, //!< Operation success.
    GAP_CAUSE_ALREADY_IN_REQ    = 0x01, //!< Operation already in progress.
    GAP_CAUSE_INVALID_STATE     = 0x02, //!< Invalid state.
    GAP_CAUSE_INVALID_PARAM     = 0x03, //!< Invalid parameter.
    GAP_CAUSE_NON_CONN          = 0x04, //!< No connection establishment.
    GAP_CAUSE_NOT_FIND_IRK      = 0x05, //!< IRK not found.
    GAP_CAUSE_ERROR_CREDITS     = 0x06, //!< Credits error.
    GAP_CAUSE_SEND_REQ_FAILED   = 0x07, //!< Send Request failed.
    GAP_CAUSE_NO_RESOURCE       = 0x08, //!< No resource.
    GAP_CAUSE_INVALID_PDU_SIZE  = 0x09, //!< Invalid PDU size.
    GAP_CAUSE_NOT_FIND          = 0x0A, //!< Not Found.
    GAP_CAUSE_CONN_LIMIT        = 0x0B, //!< Connection reaches limited count.
    GAP_CAUSE_NO_BOND           = 0x0C, //!< No Bond.
    GAP_CAUSE_ERROR_UNKNOWN     = 0xFF, //!< Unknown error.
} T_GAP_CAUSE;

/** @brief GAP Confirmation Cause. */
typedef enum
{
    GAP_CFM_CAUSE_ACCEPT = (GAP_ERR | GAP_ACCEPT),    /**< Accept for indication, only used when confirmation. */
    GAP_CFM_CAUSE_REJECT = (GAP_ERR | GAP_ERR_REJECT),/**< Reject for indication, only used when confirmation. */
} T_GAP_CFM_CAUSE;

/** @brief APP Return Result. */
typedef enum
{
    APP_RESULT_SUCCESS                    = (APP_SUCCESS),
    APP_RESULT_PENDING                    = (APP_ERR | APP_ERR_PENDING),
    APP_RESULT_ACCEPT                     = (APP_ERR | APP_ERR_ACCEPT),
    APP_RESULT_REJECT                     = (APP_ERR | APP_ERR_REJECT),
    APP_RESULT_NOT_RELEASE                = (APP_ERR | APP_ERR_NOT_RELEASE),

    APP_RESULT_PREP_QUEUE_FULL            = (ATT_ERR | ATT_ERR_PREP_QUEUE_FULL),
    APP_RESULT_INVALID_OFFSET             = (ATT_ERR | ATT_ERR_INVALID_OFFSET),
    APP_RESULT_INVALID_VALUE_SIZE         = (ATT_ERR | ATT_ERR_INVALID_VALUE_SIZE),
    APP_RESULT_INVALID_PDU                = (ATT_ERR | ATT_ERR_INVALID_PDU),
    APP_RESULT_ATTR_NOT_FOUND             = (ATT_ERR | ATT_ERR_ATTR_NOT_FOUND),
    APP_RESULT_ATTR_NOT_LONG              = (ATT_ERR | ATT_ERR_ATTR_NOT_LONG),
    APP_RESULT_INSUFFICIENT_RESOURCES     = (ATT_ERR | ATT_ERR_INSUFFICIENT_RESOURCES),
    APP_RESULT_VALUE_NOT_ALLOWED          = (ATT_ERR | ATT_ERR_VALUE_NOT_ALLOWED),
    APP_RESULT_APP_ERR                    = (ATT_ERR | ATT_ERR_MIN_APPLIC_CODE),
    APP_RESULT_CCCD_IMPROPERLY_CONFIGURED = (ATT_ERR | ATT_ERR_CCCD_IMPROPERLY_CONFIGURED),
    APP_RESULT_PROC_ALREADY_IN_PROGRESS   = (ATT_ERR | ATT_ERR_PROC_ALREADY_IN_PROGRESS),
} T_APP_RESULT;

/** @brief GAP Parameter. */
typedef enum
{
    GAP_PARAM_BD_ADDR                        = 0x200, /**< Public device address. Read only. Size is 6 octets @ref GAP_BD_ADDR_LEN. */
    GAP_PARAM_BOND_PAIRING_MODE              = 0x202, //!< Pairing Mode of LE and BR/EDR. Write only. Size is 1 octet. Value is @ref BOND_PAIRING_MODE_DEFINES. Default value is @ref GAP_PAIRING_MODE_PAIRABLE.
    GAP_PARAM_BOND_AUTHEN_REQUIREMENTS_FLAGS = 0x203, /**< Authentication requirements. Write only. Size is 2 octets.
                                                       *   Value is @ref BOND_AUTHEN_REQ. Default value is @ref GAP_AUTHEN_BIT_BONDING_FLAG. */
    GAP_PARAM_BOND_IO_CAPABILITIES           = 0x204, //!< IO capabilities. Read/Write. Size is 1 octet. Value is @ref T_GAP_IO_CAP. Default value is @ref GAP_IO_CAP_NO_INPUT_NO_OUTPUT.
    GAP_PARAM_BOND_OOB_ENABLED               = 0x205, //!< OOB data available for pairing algorithm. Read/Write. Size is 1 octet. Default value is 0(disabled).
    GAP_PARAM_BOND_LINK_KEY_CONVERT          = 0x206, //!< Link Key Convert. Write only. Size is 1 octet. Value is @ref BOND_KEY_CONVERT. Default value is @ref GAP_SC_KEY_CONVERT_NONE.
    GAP_PARAM_BOND_BR_PAIRING_MODE              = 0x208, //!< BR/EDR Pairing Mode. Read/Write. Size is 1 octet. Value is @ref BOND_PAIRING_MODE_DEFINES. Default value is @ref GAP_PAIRING_MODE_PAIRABLE.
    GAP_PARAM_BOND_BR_AUTHEN_REQUIREMENTS_FLAGS = 0x209, /**< BR/EDR authentication requirements. Write only. Size is 2 octets.
                                                          *   Value is @ref BOND_AUTHEN_REQ. Default value is @ref GAP_AUTHEN_BIT_BONDING_FLAG. */
    GAP_PARAM_BOND_BR_IO_CAPABILITIES           = 0x20A, //!< BR/EDR IO capabilities. Write only. Size is 1 octet. Value is @ref T_GAP_IO_CAP. Default value is @ref GAP_IO_CAP_NO_INPUT_NO_OUTPUT.
    GAP_PARAM_BOND_LE_PAIRING_MODE              = 0x207, //!< LE Pairing Mode. Read/Write. Size is 1 octet. Value is @ref BOND_PAIRING_MODE_DEFINES. Default value is @ref GAP_PAIRING_MODE_PAIRABLE.
    GAP_PARAM_BOND_LE_AUTHEN_REQUIREMENTS_FLAGS = 0x20B, /**< LE authentication requirements. Write only. Size is 2 octets.
                                                          *   Value is @ref BOND_AUTHEN_REQ. Default value is @ref GAP_AUTHEN_BIT_BONDING_FLAG. */
    GAP_PARAM_BOND_LE_IO_CAPABILITIES           = 0x20C, //!< LE IO capabilities. Write only. Size is 1 octet. Value is @ref T_GAP_IO_CAP. Default value is @ref GAP_IO_CAP_NO_INPUT_NO_OUTPUT.
} T_GAP_PARAM_TYPE;

/** @brief GAP PA Sync Advertiser Address Type. */
typedef enum
{
    PA_SYNC_ADV_ADDR_PUBLIC              = 0x00, /**< Public Device Address for reception of info; otherwise, Public Device Address or Public Identity Address. */
    PA_SYNC_ADV_ADDR_RANDOM              = 0x01, /**< Random Device Address for reception of info; otherwise, Random Device Address or Random (static) Identity Address. */
    PA_SYNC_ADV_ADDR_RPA_PUBLIC_IDENTITY = 0x02, /**< Public Identity Address (corresponds to Resolved Private Address), only for reception of info. */
    PA_SYNC_ADV_ADDR_RPA_RANDOM_IDENTITY = 0x03, /**< Random (static) Identity Address (corresponds to Resolved Private Address), only for reception of info. */
} T_GAP_PA_SYNC_ADV_ADDR_TYPE;

/** @brief Response for write airplane mode. */
typedef struct
{
    uint16_t        cause; //!< Write response cause.
} T_GAP_WRITE_AIRPLAN_MODE_RSP;

/** @brief Response for read airplane mode. */
typedef struct
{
    uint16_t cause;  //!< Read response cause.
    uint8_t  mode;   /**< Current airplane mode.
                      *  - 0x00:    Airplane mode disable.
                      *  - 0x01:    Airplane mode enable. */
} T_GAP_READ_AIRPLAN_MODE_RSP;

/** @brief Vendor command response. */
typedef struct
{
    uint16_t command;      /**< Vendor command. Should be the same as that in request. */
    uint16_t cause;        /**< Result of executing command. */
    bool     is_cmpl_evt;  /**< Whether the response is generated from command complete event. */
    uint8_t  param_len;    /**< Response parameter length. */
    uint8_t  param[1];     /**< Response parameter buffer. */
} T_GAP_VENDOR_CMD_RSP;

/** @brief Response for set local public address. */
typedef struct
{
    uint16_t cause;       //!< Set response cause.
    uint8_t  bd_addr[6];  //!< Public bluetooth address.
} T_GAP_SET_BD_ADDR_RSP;

/** @brief Read AFH channel assessment mode response. */
typedef struct
{
    uint16_t cause;                       //!< Read response cause.
    uint8_t  afh_channel_assessment_mode; /**< Controller's channel assessment scheme.
                                           *   - 0x00: Controller channel assessment disabled.
                                           *   - 0x01: Controller channel assessment enabled. */
} T_GAP_READ_AFH_CHANNEL_ASSESSMENT_MODE_RSP;

/** @brief Write AFH channel assessment mode response. */
typedef struct
{
    uint16_t cause;
} T_GAP_WRITE_AFH_CHANNEL_ASSESSMENT_MODE_RSP;

/** @brief Information for L2CAP channel added. This L2CAP channel can transmit ATT PDU. */
typedef struct
{
    T_GAP_CHANN_TYPE chann_type;
    uint16_t         conn_handle;
    uint16_t         cid;
    uint16_t         mtu_size;
} T_GAP_CHANN_ADDED;

/** @brief Information for L2CAP channel removed. */
typedef struct
{
    uint16_t conn_handle;
    uint16_t cid;
} T_GAP_CHANN_DEL;

/** @brief Information for L2CAP channel MTU updated. */
typedef struct
{
    uint16_t conn_handle;
    uint16_t cid;
    uint16_t mtu_size;
} T_GAP_CHANN_MTU_UPDATE;

/** @brief Vendor event information. */
typedef struct
{
    uint8_t param_len; /**< Information parameter length. */
    uint8_t param[1];  /**< Information parameter buffer. */
} T_GAP_VENDOR_EVT_INFO;

/** @brief GAP callback data. */
typedef union
{
    T_GAP_WRITE_AIRPLAN_MODE_RSP *p_gap_write_airplan_mode_rsp;
    T_GAP_READ_AIRPLAN_MODE_RSP  *p_gap_read_airplan_mode_rsp;
    T_GAP_VENDOR_CMD_RSP         *p_gap_vendor_cmd_rsp;
    T_GAP_VENDOR_EVT_INFO        *p_gap_vendor_evt_info;
    T_GAP_SET_BD_ADDR_RSP        *p_gap_set_bd_addr_rsp;

    T_GAP_READ_AFH_CHANNEL_ASSESSMENT_MODE_RSP *p_read_afh_channel_assessment_mode_rsp;
    T_GAP_WRITE_AFH_CHANNEL_ASSESSMENT_MODE_RSP *p_write_afh_channel_assessment_mode_rsp;

    T_GAP_CHANN_ADDED            *p_gap_chann_added;
    T_GAP_CHANN_DEL              *p_gap_chann_del;
    T_GAP_CHANN_MTU_UPDATE       *p_gap_chann_mtu_update;

    void                         *p_gap_cb_data;
} T_GAP_CB_DATA;

/** End of GAP_Common_Exported_Types
  * @}
  */

/*============================================================================*
 *                         Functions
 *============================================================================*/
/**
 * @defgroup GAP_COMMON_EXPORT_Functions GAP Common Exported Functions
 *
 * @{
 */

/**
 * @brief  Callback for GAP to notify APP.
 *
 * @param[in] cb_type Callback msg type @ref GAP_COMMON_MSG_TYPE.
 * @param[in] p_cb_data Point to callback data @ref T_GAP_CB_DATA.
 */
typedef void(*P_FUN_GAP_APP_CB)(uint8_t cb_type, void *p_cb_data);

/**
 * @brief  Make Bluetooth Host ready to use by sending the register request.
 *
 * @param[in] evt_queue     Event queue handle which is created by APP.
 * @param[in] io_queue      IO message queue handle which is created by APP.
 * @param[in] msg_queue_elem_num  Number of GAP message queue which will be created by GAP module.
 *
 * @return Operation result.
 * @retval true  Operation success.
 * @retval false Operation failure.
 *
 * <b>Example usage</b>
 * \code{.c}
    void app_main_task(void *p_param)
    {
        uint8_t event;
        os_msg_queue_create(&io_queue_handle, MAX_NUMBER_OF_IO_MESSAGE, sizeof(T_IO_MSG));
        os_msg_queue_create(&evt_queue_handle, MAX_NUMBER_OF_EVENT_MESSAGE, sizeof(uint8_t));

        gap_start_bt_stack(evt_queue_handle, io_queue_handle, MAX_NUMBER_OF_GAP_MESSAGE);

        while (true)
        {
            if (os_msg_recv(evt_queue_handle, &event, 0xFFFFFFFF) == true)
            {
                if (event == EVENT_IO_TO_APP)
                {
                    T_IO_MSG io_msg;
                    if (os_msg_recv(io_queue_handle, &io_msg, 0) == true)
                    {
                        app_handle_io_msg(io_msg);
                    }
                }
                else
                {
                    gap_handle_msg(event);
                }
            }
        }
    }
 * \endcode
 */
bool gap_start_bt_stack(void *evt_queue, void *io_queue, uint16_t msg_queue_elem_num);

/**
 * @brief  Initialize GAP lib to use some extended functions.
 *
 * <b>Example usage</b>
 * \code{.c}
    int main(void)
    {
        ...
        gap_lib_init();
        ...
    }
 * \endcode
 */
void gap_lib_init(void);

/**
 * @brief  Register callback to GAP, when messages in @ref GAP_COMMON_MSG_TYPE happen, it will callback to APP.
 *
 * @param[in] app_callback Callback function provided by the APP to handle GAP common messages sent from the GAP.
 *              - NULL -> Not send GAP common messages to APP.
 *              - Other -> Use application defined callback function.
 *
 * <b>Example usage</b>
 * \code{.c}
   void app_le_gap_init()
   {
       ...
       le_register_app_cb(app_gap_callback);
       gap_register_app_cb(app_gap_common_callback);
   }
   \endcode
 */
void gap_register_app_cb(P_FUN_GAP_APP_CB app_callback);

/**
  * @brief  Set a GAP parameter.
  *
  * This function can be called with a GAP common parameter type @ref T_GAP_PARAM_TYPE and it will set GAP parameter.
  * The 'p_value' field must point to an appropriate data type that meets the requirements for the corresponding parameter type.
  * (For example: if required data length for parameter type is 2 octets, p_value should be cast to a pointer of uint16_t.)
  *
  * @param[in]  param @ref T_GAP_PARAM_TYPE.
  * @param[in]  len Length of data to write.
  * @param[in]  p_value Pointer to data to write.
  *
  * @return Operation result.
  * @retval GAP_CAUSE_SUCCESS Operation success.
  * @retval Others Operation failure.
  *
  * <b>Example usage</b>
  * \code{.c}
    void app_le_gap_init(void)
    {
        ...
        //GAP Bond Manager parameters
        uint8_t  auth_pair_mode = GAP_PAIRING_MODE_PAIRABLE;
        uint16_t auth_flags = GAP_AUTHEN_BIT_BONDING_FLAG | GAP_AUTHEN_BIT_MITM_FLAG;
        uint8_t  auth_io_cap = GAP_IO_CAP_NO_INPUT_NO_OUTPUT;
        uint8_t  auth_oob = false;

        // Setup the GAP Bond Manager
        gap_set_param(GAP_PARAM_BOND_PAIRING_MODE, sizeof(auth_pair_mode), &auth_pair_mode);
        gap_set_param(GAP_PARAM_BOND_AUTHEN_REQUIREMENTS_FLAGS, sizeof(auth_flags), &auth_flags);
        gap_set_param(GAP_PARAM_BOND_IO_CAPABILITIES, sizeof(auth_io_cap), &auth_io_cap);
        gap_set_param(GAP_PARAM_BOND_OOB_ENABLED, sizeof(auth_oob), &auth_oob);
        ...
    }
  * \endcode
  */
T_GAP_CAUSE gap_set_param(T_GAP_PARAM_TYPE param, uint8_t len, void *p_value);

/**
  * @brief  Get a GAP Common parameter.
  *
  * This function can be called with a GAP common parameter type @ref T_GAP_PARAM_TYPE and it will get GAP parameter.
  * The 'p_value' field must point to an appropriate data type that meets the requirements for the corresponding parameter type.
  * (For example: if required data length for parameter type is 2 octets, p_value should be cast to a pointer of uint16_t.)
  *
  * @param[in]  param @ref T_GAP_PARAM_TYPE.
  * @param[in,out]  p_value Pointer to location to get the value.
  *
  * @return Operation result.
  * @retval GAP_CAUSE_SUCCESS Operation success.
  * @retval Others Operation failure.
  *
  * <b>Example usage</b>
  * \code{.c}
    void test(void)
    {
        uint8_t bt_addr[6];
        gap_get_param(GAP_PARAM_BD_ADDR, bt_addr);
    }
  * \endcode
  */
T_GAP_CAUSE gap_get_param(T_GAP_PARAM_TYPE param, void *p_value);

/**
  * @brief  Make the device in pairable mode.
  *
  * @return Operation result.
  * @retval GAP_CAUSE_SUCCESS Operation success.
  * @retval Others Operation failure.
  */
T_GAP_CAUSE gap_set_pairable_mode(void);

/**
 * @brief  Enable/disable airplane mode of the device.
 *
 * If sending request operation is successful, the enabling/disabling result will be returned by callback
 * registered by @ref gap_register_app_cb with msg type @ref GAP_MSG_WRITE_AIRPLAN_MODE.
 *
 * Applications can only call this API after Bluetooth Host is ready.
 *
 * Explanation: If Bluetooth Host is ready, the application will be notified by message @ref GAP_MSG_LE_DEV_STATE_CHANGE
 * with new_state about gap_init_state which is configured as @ref GAP_INIT_STATE_STACK_READY.
 *
 * @param[in] mode Airplane mode of the device.
 *                 - 0x00:  Disable.
 *                 - 0x01:  Enable.
 *
 * @return The result of sending request.
 * @retval GAP_CAUSE_SUCCESS Sending request operation is successful.
 * @retval Others Sending request operation is failed.
 *
 * <b>Example usage</b>
 * \code{.c}
    void test(void)
    {
        T_GAP_CAUSE cause = gap_write_airplan_mode(mode);
    }

    void app_gap_common_callback(uint8_t cb_type, void *p_cb_data)
    {
        T_GAP_CB_DATA cb_data;
        memcpy(&cb_data, p_cb_data, sizeof(T_GAP_CB_DATA));
        APP_PRINT_INFO1("app_gap_common_callback: cb_type %d", cb_type);
        switch (cb_type)
        {
        case GAP_MSG_WRITE_AIRPLAN_MODE:
            APP_PRINT_INFO1("GAP_MSG_WRITE_AIRPLAN_MODE: cause 0x%x",
                            cb_data.p_gap_write_airplan_mode_rsp->cause);
            break;
        case GAP_MSG_READ_AIRPLAN_MODE:
            APP_PRINT_INFO2("GAP_MSG_READ_AIRPLAN_MODE: cause 0x%x, mode %d",
                            cb_data.p_gap_read_airplan_mode_rsp->cause,
                            cb_data.p_gap_read_airplan_mode_rsp->mode);
            break;
        default:
            break;
        }
        return;
    }
 * \endcode
 */
T_GAP_CAUSE gap_write_airplan_mode(uint8_t mode);

/**
 * @brief  Read the airplane mode of the device.
 *
 * If sending request operation is successful, the reading result will be returned by callback
 * registered by @ref gap_register_app_cb with msg type @ref GAP_MSG_READ_AIRPLAN_MODE.
 *
 * Applications can only call this API after Bluetooth Host is ready.
 *
 * Explanation: If Bluetooth Host is ready, the application will be notified by message @ref GAP_MSG_LE_DEV_STATE_CHANGE
 * with new_state about gap_init_state which is configured as @ref GAP_INIT_STATE_STACK_READY.
 *
 * @return The result of sending request.
 * @retval GAP_CAUSE_SUCCESS Sending request operation is successful.
 * @retval Others Sending request operation is failed.
 *
 * <b>Example usage</b>
 * \code{.c}
    void test(void)
    {
        T_GAP_CAUSE cause = gap_read_airplan_mode();
    }

    void app_gap_common_callback(uint8_t cb_type, void *p_cb_data)
    {
        T_GAP_CB_DATA cb_data;
        memcpy(&cb_data, p_cb_data, sizeof(T_GAP_CB_DATA));
        APP_PRINT_INFO1("app_gap_common_callback: cb_type %d", cb_type);
        switch (cb_type)
        {
        case GAP_MSG_WRITE_AIRPLAN_MODE:
            APP_PRINT_INFO1("GAP_MSG_WRITE_AIRPLAN_MODE: cause 0x%x",
                            cb_data.p_gap_write_airplan_mode_rsp->cause);
            break;
        case GAP_MSG_READ_AIRPLAN_MODE:
            APP_PRINT_INFO2("GAP_MSG_READ_AIRPLAN_MODE: cause 0x%x, mode %d",
                            cb_data.p_gap_read_airplan_mode_rsp->cause,
                            cb_data.p_gap_read_airplan_mode_rsp->mode);
            break;
        default:
            break;
        }
        return;
    }
 * \endcode
 */
T_GAP_CAUSE gap_read_airplan_mode(void);

/**
 * @brief  Set public address of local device.
 *
 * If sending request operation is successful, the setting result will be returned by callback
 * registered by @ref gap_register_app_cb with msg type @ref GAP_MSG_SET_LOCAL_BD_ADDR.
 *
 * Applications can only call this API after Bluetooth Host is ready.
 *
 * Explanation: If Bluetooth Host is ready, the application will be notified by message @ref GAP_MSG_LE_DEV_STATE_CHANGE
 * with new_state about gap_init_state which is configured as @ref GAP_INIT_STATE_STACK_READY.
 *
 * @param[in] bd_addr   Bluetooth device address.
 *
 * @return The result of sending request.
 * @retval GAP_CAUSE_SUCCESS Sending request operation is successful.
 * @retval Others Sending request operation is failed.
 *
 * <b>Example usage</b>
 * \code{.c}
    void test(void)
    {
        uint8_t bd_addr[6] = {0x00, 0x11, 0x22, 0x33, 0x44, 0x55};
        T_GAP_CAUSE ret = gap_set_bd_addr(bd_addr);
    }

    void app_gap_common_callback(uint8_t cb_type, void *p_cb_data)
    {
        T_GAP_CB_DATA cb_data;
        memcpy(&cb_data, p_cb_data, sizeof(T_GAP_CB_DATA));
        APP_PRINT_INFO1("app_gap_common_callback: cb_type %d", cb_type);
        switch (cb_type)
        {
        case GAP_MSG_SET_LOCAL_BD_ADDR:
            APP_PRINT_INFO1("GAP_MSG_SET_LOCAL_BD_ADDR: cause 0x%x",
                            cb_data.p_gap_set_bd_addr_rsp->cause);
            break;
        default:
            break;
        }
        return;
    }
 * \endcode
 */
T_GAP_CAUSE gap_set_bd_addr(uint8_t *bd_addr);

/**
 * @brief  Handle GAP message received from Bluetooth Host.
 *
 * @param[in] event Event type which is received from APP event queue.
 *
 * <b>Example usage</b>
 * \code{.c}
    void app_main_task(void *p_param)
    {
        uint8_t event;
        os_msg_queue_create(&io_queue_handle, MAX_NUMBER_OF_IO_MESSAGE, sizeof(T_IO_MSG));
        os_msg_queue_create(&evt_queue_handle, MAX_NUMBER_OF_EVENT_MESSAGE, sizeof(uint8_t));

        gap_start_bt_stack(evt_queue_handle, io_queue_handle, MAX_NUMBER_OF_GAP_MESSAGE);

        while (true)
        {
            if (os_msg_recv(evt_queue_handle, &event, 0xFFFFFFFF) == true)
            {
                if (event == EVENT_IO_TO_APP)
                {
                    T_IO_MSG io_msg;
                    if (os_msg_recv(io_queue_handle, &io_msg, 0) == true)
                    {
                        app_handle_io_msg(io_msg);
                    }
                }
                else
                {
                    gap_handle_msg(event);
                }
            }
        }
    }
 * \endcode
 */
void gap_handle_msg(uint8_t event);

/**
 * @brief  Release the buffer supplied by GAP.
 *
 * @param[in] p_buf Pointer to the buffer that needs to be released.
 *
 * @return Operation result.
 * @retval GAP_CAUSE_SUCCESS Operation successful.
 * @retval Others Operation failure.
 *
 * <b>Example usage</b>
 * \code{.c}
    uint8_t *p_data_buf;
    uint16_t data_offset;
    T_APP_RESULT simp_ble_service_attr_write_cb(uint8_t conn_id, T_SERVER_ID service_id,
                                            uint16_t attrib_index, T_WRITE_TYPE write_type, uint16_t length, uint8_t *p_value,
                                            P_FUN_WRITE_IND_POST_PROC *p_write_ind_post_proc)
    {
        ......
        server_get_write_cmd_data_buffer(conn_id, &p_data_buf, &data_offset);
        return APP_RESULT_NOT_RELEASE;
    }
    void release(void)
    {
        if (p_data_buf != NULL)
        {
            gap_buffer_free(p_data_buf);
            p_data_buf = NULL;
        }
    }
 * \endcode
 */
T_GAP_CAUSE gap_buffer_free(void *p_buf);

/**
 * @brief  Read the value for the Controller's channel assessment scheme.
 *
 * If sending request operation is successful, the reading result will be returned by callback
 * registered by @ref gap_register_app_cb with msg type @ref GAP_MSG_GAP_READ_AFH_CHANNEL_ASSESSMENT_MODE.
 *
 * Applications can only call this API after Bluetooth Host is ready.
 *
 * Explanation: If Bluetooth Host is ready, the application will be notified by message @ref GAP_MSG_LE_DEV_STATE_CHANGE
 * with new_state about gap_init_state which is configured as @ref GAP_INIT_STATE_STACK_READY.
 *
 * @return The result of sending request.
 * @retval GAP_CAUSE_SUCCESS Sending request operation is successful.
 * @retval Others Sending request operation is failed.
 *
 * <b>Example usage</b>
 * \code{.c}
    void test(void)
    {
        T_GAP_CAUSE cause = gap_read_afh_channel_assessment_mode();
    }

    void app_gap_common_callback(uint8_t cb_type, void *p_cb_data)
    {
        T_GAP_CB_DATA cb_data;

        memcpy(&cb_data, p_cb_data, sizeof(T_GAP_CB_DATA));

        switch (cb_type)
        {
        case GAP_MSG_GAP_READ_AFH_CHANNEL_ASSESSMENT_MODE:
            APP_PRINT_INFO2("GAP_MSG_GAP_READ_AFH_CHANNEL_ASSESSMENT_MODE: cause 0x%x, afh_channel_assessment_mode %d",
                            cb_data.p_read_afh_channel_assessment_mode_rsp->cause,
                            cb_data.p_read_afh_channel_assessment_mode_rsp->afh_channel_assessment_mode);
            break;
        ......
        }
        ......
    }
 * \endcode
 */
T_GAP_CAUSE gap_read_afh_channel_assessment_mode(void);

/**
 * @brief  Write the value for the Controller's channel assessment scheme.
 *
 * If sending request operation is successful, the writing result will be returned by callback
 * registered by @ref gap_register_app_cb with msg type @ref GAP_MSG_GAP_WRITE_AFH_CHANNEL_ASSESSMENT_MODE.
 *
 * Applications can only call this API after Bluetooth Host is ready.
 *
 * Explanation: If Bluetooth Host is ready, the application will be notified by message @ref GAP_MSG_LE_DEV_STATE_CHANGE
 * with new_state about gap_init_state which is configured as @ref GAP_INIT_STATE_STACK_READY.
 *
 * @param[in] afh_channel_assessment_mode  Controller's channel assessment scheme.
 *                                         - 0x00: Controller channel assessment disabled.
 *                                         - 0x01: Controller channel assessment enabled.
 *
 * @return The result of sending request.
 * @retval GAP_CAUSE_SUCCESS Sending request operation is successful.
 * @retval Others Sending request operation is failed.
 *
 * <b>Example usage</b>
 * \code{.c}
    void test(void)
    {
        T_GAP_CAUSE cause = gap_write_afh_channel_assessment_mode(afh_channel_assessment_mode);
    }

    void app_gap_common_callback(uint8_t cb_type, void *p_cb_data)
    {
        T_GAP_CB_DATA cb_data;

        memcpy(&cb_data, p_cb_data, sizeof(T_GAP_CB_DATA));

        switch (cb_type)
        {
        case GAP_MSG_GAP_WRITE_AFH_CHANNEL_ASSESSMENT_MODE:
            APP_PRINT_INFO1("GAP_MSG_GAP_WRITE_AFH_CHANNEL_ASSESSMENT_MODE: cause 0x%x",
                            cb_data.p_write_afh_channel_assessment_mode_rsp->cause);
            break;
        ......
        }
        ......
    }
 * \endcode
 */
T_GAP_CAUSE gap_write_afh_channel_assessment_mode(uint8_t afh_channel_assessment_mode);
/** @} */ /* End of group GAP_COMMON_EXPORT_Functions */

/** @} */ /* End of group GAP_COMMON */

#ifdef __cplusplus
}
#endif

#endif /* GAP_H */
